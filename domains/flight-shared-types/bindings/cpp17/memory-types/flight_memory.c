// Generated by `wit-bindgen` 0.42.1. DO NOT EDIT!
#include "flight_memory.h"
#include <stdlib.h>
#include <string.h>

// Exported Functions from `flight:memory/memory-operations@1.0.0`

__attribute__((__weak__, __export_name__("cabi_post_flight:memory/memory-operations@1.0.0#create-allocation")))
void __wasm_export_exports_flight_memory_memory_operations_create_allocation_post_return(uint8_t * arg0) {
  switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + 0))) {
    case 0: {
      if ((*((size_t*) (arg0 + (8+1*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + 8)));
      }
      if ((*((size_t*) (arg0 + (8+3*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + (8+2*sizeof(void*)))));
      }
      if ((*((size_t*) (arg0 + (16+5*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + (16+4*sizeof(void*)))));
      }
      break;
    }
    case 1: {
      if ((*((size_t*) (arg0 + (8+2*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + (8+1*sizeof(void*)))));
      }
      switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + (8+3*sizeof(void*))))) {
        case 0: {
          break;
        }
        case 1: {
          if ((*((size_t*) (arg0 + (8+5*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (arg0 + (8+4*sizeof(void*)))));
          }
          break;
        }
      }
      break;
    }
  }
}

__attribute__((__weak__, __export_name__("cabi_post_flight:memory/memory-operations@1.0.0#free-allocation")))
void __wasm_export_exports_flight_memory_memory_operations_free_allocation_post_return(uint8_t * arg0) {
  switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + 0))) {
    case 0: {
      break;
    }
    case 1: {
      if ((*((size_t*) (arg0 + (8+2*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + (8+1*sizeof(void*)))));
      }
      switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + (8+3*sizeof(void*))))) {
        case 0: {
          break;
        }
        case 1: {
          if ((*((size_t*) (arg0 + (8+5*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (arg0 + (8+4*sizeof(void*)))));
          }
          break;
        }
      }
      break;
    }
  }
}

__attribute__((__weak__, __export_name__("cabi_post_flight:memory/memory-operations@1.0.0#get-memory-snapshot")))
void __wasm_export_exports_flight_memory_memory_operations_get_memory_snapshot_post_return(uint8_t * arg0) {
  switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + 0))) {
    case 0: {
      if ((*((size_t*) (arg0 + (16+1*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + 16)));
      }
      if ((*((size_t*) (arg0 + (16+3*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + (16+2*sizeof(void*)))));
      }
      if ((*((size_t*) (arg0 + (24+5*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + (24+4*sizeof(void*)))));
      }
      if ((*((size_t*) (arg0 + (32+7*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + (32+6*sizeof(void*)))));
      }
      if ((*((size_t*) (arg0 + (40+9*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + (40+8*sizeof(void*)))));
      }
      break;
    }
    case 1: {
      if ((*((size_t*) (arg0 + (8+2*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + (8+1*sizeof(void*)))));
      }
      switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + (8+3*sizeof(void*))))) {
        case 0: {
          break;
        }
        case 1: {
          if ((*((size_t*) (arg0 + (8+5*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (arg0 + (8+4*sizeof(void*)))));
          }
          break;
        }
      }
      break;
    }
  }
}

__attribute__((__weak__, __export_name__("cabi_post_flight:memory/memory-operations@1.0.0#get-platform-profile")))
void __wasm_export_exports_flight_memory_memory_operations_get_platform_profile_post_return(uint8_t * arg0) {
  switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + 0))) {
    case 0: {
      switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + 8))) {
        case 0: {
          if ((*((size_t*) (arg0 + (24+1*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (arg0 + 24)));
          }
          break;
        }
        case 1: {
          if ((*((size_t*) (arg0 + (24+1*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (arg0 + 24)));
          }
          break;
        }
        case 2: {
          if ((*((size_t*) (arg0 + (24+1*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (arg0 + 24)));
          }
          break;
        }
        case 3: {
          if ((*((size_t*) (arg0 + (24+1*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (arg0 + 24)));
          }
          break;
        }
        case 4: {
          if ((*((size_t*) (arg0 + (24+1*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (arg0 + 24)));
          }
          break;
        }
        case 5: {
          if ((*((size_t*) (arg0 + (24+1*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (arg0 + 24)));
          }
          break;
        }
        case 6: {
          if ((*((size_t*) (arg0 + (24+1*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (arg0 + 24)));
          }
          break;
        }
      }
      break;
    }
    case 1: {
      if ((*((size_t*) (arg0 + (8+2*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + (8+1*sizeof(void*)))));
      }
      switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + (8+3*sizeof(void*))))) {
        case 0: {
          break;
        }
        case 1: {
          if ((*((size_t*) (arg0 + (8+5*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (arg0 + (8+4*sizeof(void*)))));
          }
          break;
        }
      }
      break;
    }
  }
}

__attribute__((__weak__, __export_name__("cabi_post_flight:memory/memory-operations@1.0.0#set-memory-limits")))
void __wasm_export_exports_flight_memory_memory_operations_set_memory_limits_post_return(uint8_t * arg0) {
  switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + 0))) {
    case 0: {
      break;
    }
    case 1: {
      if ((*((size_t*) (arg0 + (8+2*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + (8+1*sizeof(void*)))));
      }
      switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + (8+3*sizeof(void*))))) {
        case 0: {
          break;
        }
        case 1: {
          if ((*((size_t*) (arg0 + (8+5*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (arg0 + (8+4*sizeof(void*)))));
          }
          break;
        }
      }
      break;
    }
  }
}

__attribute__((__weak__, __export_name__("cabi_post_flight:memory/memory-operations@1.0.0#get-memory-limits")))
void __wasm_export_exports_flight_memory_memory_operations_get_memory_limits_post_return(uint8_t * arg0) {
  switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + 0))) {
    case 0: {
      if ((*((size_t*) (arg0 + (16+1*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + 16)));
      }
      if ((*((size_t*) (arg0 + (24+3*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + (24+2*sizeof(void*)))));
      }
      if ((*((size_t*) (arg0 + (32+5*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + (32+4*sizeof(void*)))));
      }
      if ((*((size_t*) (arg0 + (40+7*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + (40+6*sizeof(void*)))));
      }
      if ((*((size_t*) (arg0 + (48+9*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + (48+8*sizeof(void*)))));
      }
      break;
    }
    case 1: {
      if ((*((size_t*) (arg0 + (8+2*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + (8+1*sizeof(void*)))));
      }
      switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + (8+3*sizeof(void*))))) {
        case 0: {
          break;
        }
        case 1: {
          if ((*((size_t*) (arg0 + (8+5*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (arg0 + (8+4*sizeof(void*)))));
          }
          break;
        }
      }
      break;
    }
  }
}

__attribute__((__weak__, __export_name__("cabi_post_flight:memory/memory-operations@1.0.0#get-memory-pressure")))
void __wasm_export_exports_flight_memory_memory_operations_get_memory_pressure_post_return(uint8_t * arg0) {
  switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + 0))) {
    case 0: {
      break;
    }
    case 1: {
      if ((*((size_t*) (arg0 + (8+2*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + (8+1*sizeof(void*)))));
      }
      switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + (8+3*sizeof(void*))))) {
        case 0: {
          break;
        }
        case 1: {
          if ((*((size_t*) (arg0 + (8+5*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (arg0 + (8+4*sizeof(void*)))));
          }
          break;
        }
      }
      break;
    }
  }
}

__attribute__((__weak__, __export_name__("cabi_post_flight:memory/memory-operations@1.0.0#validate-allocation-request")))
void __wasm_export_exports_flight_memory_memory_operations_validate_allocation_request_post_return(uint8_t * arg0) {
  switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + 0))) {
    case 0: {
      break;
    }
    case 1: {
      if ((*((size_t*) (arg0 + (8+2*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + (8+1*sizeof(void*)))));
      }
      switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + (8+3*sizeof(void*))))) {
        case 0: {
          break;
        }
        case 1: {
          if ((*((size_t*) (arg0 + (8+5*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (arg0 + (8+4*sizeof(void*)))));
          }
          break;
        }
      }
      break;
    }
  }
}

__attribute__((__weak__, __export_name__("cabi_post_flight:memory/memory-operations@1.0.0#list-allocations")))
void __wasm_export_exports_flight_memory_memory_operations_list_allocations_post_return(uint8_t * arg0) {
  switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + 0))) {
    case 0: {
      size_t len = *((size_t*) (arg0 + (8+1*sizeof(void*))));
      if (len > 0) {
        uint8_t *ptr = *((uint8_t **) (arg0 + 8));
        for (size_t i = 0; i < len; i++) {
          uint8_t *base = ptr + i * (40+6*sizeof(void*));
          (void) base;
          if ((*((size_t*) (base + sizeof(void*)))) > 0) {
            free(*((uint8_t **) (base + 0)));
          }
          if ((*((size_t*) (base + (3*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (base + (2*sizeof(void*)))));
          }
          if ((*((size_t*) (base + (8+5*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (base + (8+4*sizeof(void*)))));
          }
        }
        free(ptr);
      }
      break;
    }
    case 1: {
      if ((*((size_t*) (arg0 + (8+2*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + (8+1*sizeof(void*)))));
      }
      switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + (8+3*sizeof(void*))))) {
        case 0: {
          break;
        }
        case 1: {
          if ((*((size_t*) (arg0 + (8+5*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (arg0 + (8+4*sizeof(void*)))));
          }
          break;
        }
      }
      break;
    }
  }
}

// Exported Functions from `flight:memory/memory-analytics@1.0.0`

__attribute__((__weak__, __export_name__("cabi_post_flight:memory/memory-analytics@1.0.0#calculate-memory-stats")))
void __wasm_export_exports_flight_memory_memory_analytics_calculate_memory_stats_post_return(uint8_t * arg0) {
  switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + 0))) {
    case 0: {
      if ((*((size_t*) (arg0 + (32+1*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + 32)));
      }
      if ((*((size_t*) (arg0 + (40+3*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + (40+2*sizeof(void*)))));
      }
      if ((*((size_t*) (arg0 + (48+5*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + (48+4*sizeof(void*)))));
      }
      size_t len = *((size_t*) (arg0 + (48+7*sizeof(void*))));
      if (len > 0) {
        uint8_t *ptr = *((uint8_t **) (arg0 + (48+6*sizeof(void*))));
        for (size_t i = 0; i < len; i++) {
          uint8_t *base = ptr + i * (16+2*sizeof(void*));
          (void) base;
          if ((*((size_t*) (base + (16+1*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (base + 16)));
          }
        }
        free(ptr);
      }
      break;
    }
    case 1: {
      if ((*((size_t*) (arg0 + (8+2*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + (8+1*sizeof(void*)))));
      }
      switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + (8+3*sizeof(void*))))) {
        case 0: {
          break;
        }
        case 1: {
          if ((*((size_t*) (arg0 + (8+5*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (arg0 + (8+4*sizeof(void*)))));
          }
          break;
        }
      }
      break;
    }
  }
}

__attribute__((__weak__, __export_name__("cabi_post_flight:memory/memory-analytics@1.0.0#get-memory-trends")))
void __wasm_export_exports_flight_memory_memory_analytics_get_memory_trends_post_return(uint8_t * arg0) {
  switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + 0))) {
    case 0: {
      size_t len = *((size_t*) (arg0 + (8+1*sizeof(void*))));
      if (len > 0) {
        uint8_t *ptr = *((uint8_t **) (arg0 + 8));
        for (size_t i = 0; i < len; i++) {
          uint8_t *base = ptr + i * (40+10*sizeof(void*));
          (void) base;
          if ((*((size_t*) (base + (8+1*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (base + 8)));
          }
          if ((*((size_t*) (base + (8+3*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (base + (8+2*sizeof(void*)))));
          }
          if ((*((size_t*) (base + (16+5*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (base + (16+4*sizeof(void*)))));
          }
          if ((*((size_t*) (base + (24+7*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (base + (24+6*sizeof(void*)))));
          }
          if ((*((size_t*) (base + (32+9*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (base + (32+8*sizeof(void*)))));
          }
        }
        free(ptr);
      }
      switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + (16+2*sizeof(void*))))) {
        case 0: {
          break;
        }
        case 1: {
          if ((*((size_t*) (arg0 + (32+3*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (arg0 + (32+2*sizeof(void*)))));
          }
          break;
        }
      }
      break;
    }
    case 1: {
      if ((*((size_t*) (arg0 + (8+2*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + (8+1*sizeof(void*)))));
      }
      switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + (8+3*sizeof(void*))))) {
        case 0: {
          break;
        }
        case 1: {
          if ((*((size_t*) (arg0 + (8+5*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (arg0 + (8+4*sizeof(void*)))));
          }
          break;
        }
      }
      break;
    }
  }
}

__attribute__((__weak__, __export_name__("cabi_post_flight:memory/memory-analytics@1.0.0#generate-memory-report")))
void __wasm_export_exports_flight_memory_memory_analytics_generate_memory_report_post_return(uint8_t * arg0) {
  switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + 0))) {
    case 0: {
      if ((*((size_t*) (arg0 + (8+1*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + 8)));
      }
      break;
    }
    case 1: {
      if ((*((size_t*) (arg0 + (8+2*sizeof(void*))))) > 0) {
        free(*((uint8_t **) (arg0 + (8+1*sizeof(void*)))));
      }
      switch ((int32_t) (int32_t) *((uint8_t*) (arg0 + (8+3*sizeof(void*))))) {
        case 0: {
          break;
        }
        case 1: {
          if ((*((size_t*) (arg0 + (8+5*sizeof(void*))))) > 0) {
            free(*((uint8_t **) (arg0 + (8+4*sizeof(void*)))));
          }
          break;
        }
      }
      break;
    }
  }
}

// Canonical ABI intrinsics

__attribute__((__weak__, __export_name__("cabi_realloc")))
void *cabi_realloc(void *ptr, size_t old_size, size_t align, size_t new_size) {
  (void) old_size;
  if (new_size == 0) return (void*) align;
  void *ret = realloc(ptr, new_size);
  if (!ret) abort();
  return ret;
}

__attribute__((__aligned__(8)))
static uint8_t RET_AREA[(48+10*sizeof(void*))];

// Helper Functions

void exports_flight_memory_memory_types_memory_size_free(exports_flight_memory_memory_types_memory_size_t *ptr) {
  flight_memory_string_free(&ptr->human_readable);
}

void exports_flight_memory_memory_types_memory_usage_snapshot_free(exports_flight_memory_memory_types_memory_usage_snapshot_t *ptr) {
  flight_memory_string_free(&ptr->session_id);
  flight_memory_string_free(&ptr->platform);
  exports_flight_memory_memory_types_memory_size_free(&ptr->total);
  exports_flight_memory_memory_types_memory_size_free(&ptr->used);
  exports_flight_memory_memory_types_memory_size_free(&ptr->available);
}

void exports_flight_memory_memory_types_platform_profile_free(exports_flight_memory_memory_types_platform_profile_t *ptr) {
  switch ((int32_t) ptr->tag) {
    case 0: {
      exports_flight_memory_memory_types_memory_size_free(&ptr->val.dreamcast);
      break;
    }
    case 1: {
      exports_flight_memory_memory_types_memory_size_free(&ptr->val.psp);
      break;
    }
    case 2: {
      exports_flight_memory_memory_types_memory_size_free(&ptr->val.vita);
      break;
    }
    case 3: {
      exports_flight_memory_memory_types_memory_size_free(&ptr->val.v6r_small);
      break;
    }
    case 4: {
      exports_flight_memory_memory_types_memory_size_free(&ptr->val.v6r_medium);
      break;
    }
    case 5: {
      exports_flight_memory_memory_types_memory_size_free(&ptr->val.v6r_large);
      break;
    }
    case 6: {
      exports_flight_memory_memory_types_memory_size_free(&ptr->val.custom);
      break;
    }
  }
}

void flight_memory_option_u64_free(flight_memory_option_u64_t *ptr) {
  if (ptr->is_some) {
  }
}

void exports_flight_memory_memory_types_memory_allocation_free(exports_flight_memory_memory_types_memory_allocation_t *ptr) {
  flight_memory_string_free(&ptr->id);
  flight_memory_string_free(&ptr->session_id);
  exports_flight_memory_memory_types_memory_size_free(&ptr->size);
  flight_memory_option_u64_free(&ptr->freed_at);
}

void exports_flight_memory_memory_types_memory_limits_free(exports_flight_memory_memory_types_memory_limits_t *ptr) {
  exports_flight_memory_memory_types_memory_size_free(&ptr->heap_max);
  exports_flight_memory_memory_types_memory_size_free(&ptr->stack_max);
  exports_flight_memory_memory_types_memory_size_free(&ptr->cache_max);
  exports_flight_memory_memory_types_memory_size_free(&ptr->soft_limit);
  exports_flight_memory_memory_types_memory_size_free(&ptr->hard_limit);
}

void flight_memory_option_string_free(flight_memory_option_string_t *ptr) {
  if (ptr->is_some) {
    flight_memory_string_free(&ptr->val);
  }
}

void exports_flight_memory_memory_types_memory_error_free(exports_flight_memory_memory_types_memory_error_t *ptr) {
  flight_memory_string_free(&ptr->message);
  flight_memory_option_string_free(&ptr->details);
}

void exports_flight_memory_memory_operations_memory_size_free(exports_flight_memory_memory_operations_memory_size_t *ptr) {
  exports_flight_memory_memory_types_memory_size_free(ptr);
}

void exports_flight_memory_memory_operations_memory_allocation_free(exports_flight_memory_memory_operations_memory_allocation_t *ptr) {
  exports_flight_memory_memory_types_memory_allocation_free(ptr);
}

void exports_flight_memory_memory_operations_memory_usage_snapshot_free(exports_flight_memory_memory_operations_memory_usage_snapshot_t *ptr) {
  exports_flight_memory_memory_types_memory_usage_snapshot_free(ptr);
}

void exports_flight_memory_memory_operations_memory_error_free(exports_flight_memory_memory_operations_memory_error_t *ptr) {
  exports_flight_memory_memory_types_memory_error_free(ptr);
}

void exports_flight_memory_memory_operations_memory_limits_free(exports_flight_memory_memory_operations_memory_limits_t *ptr) {
  exports_flight_memory_memory_types_memory_limits_free(ptr);
}

void exports_flight_memory_memory_operations_platform_profile_free(exports_flight_memory_memory_operations_platform_profile_t *ptr) {
  exports_flight_memory_memory_types_platform_profile_free(ptr);
}

void exports_flight_memory_memory_operations_result_memory_allocation_memory_error_free(exports_flight_memory_memory_operations_result_memory_allocation_memory_error_t *ptr) {
  if (!ptr->is_err) {
    exports_flight_memory_memory_operations_memory_allocation_free(&ptr->val.ok);
  } else {
    exports_flight_memory_memory_operations_memory_error_free(&ptr->val.err);
  }
}

void exports_flight_memory_memory_operations_result_bool_memory_error_free(exports_flight_memory_memory_operations_result_bool_memory_error_t *ptr) {
  if (!ptr->is_err) {
  } else {
    exports_flight_memory_memory_operations_memory_error_free(&ptr->val.err);
  }
}

void exports_flight_memory_memory_operations_result_memory_usage_snapshot_memory_error_free(exports_flight_memory_memory_operations_result_memory_usage_snapshot_memory_error_t *ptr) {
  if (!ptr->is_err) {
    exports_flight_memory_memory_operations_memory_usage_snapshot_free(&ptr->val.ok);
  } else {
    exports_flight_memory_memory_operations_memory_error_free(&ptr->val.err);
  }
}

void exports_flight_memory_memory_operations_result_platform_profile_memory_error_free(exports_flight_memory_memory_operations_result_platform_profile_memory_error_t *ptr) {
  if (!ptr->is_err) {
    exports_flight_memory_memory_operations_platform_profile_free(&ptr->val.ok);
  } else {
    exports_flight_memory_memory_operations_memory_error_free(&ptr->val.err);
  }
}

void exports_flight_memory_memory_operations_result_memory_limits_memory_error_free(exports_flight_memory_memory_operations_result_memory_limits_memory_error_t *ptr) {
  if (!ptr->is_err) {
    exports_flight_memory_memory_operations_memory_limits_free(&ptr->val.ok);
  } else {
    exports_flight_memory_memory_operations_memory_error_free(&ptr->val.err);
  }
}

void exports_flight_memory_memory_operations_result_memory_pressure_memory_error_free(exports_flight_memory_memory_operations_result_memory_pressure_memory_error_t *ptr) {
  if (!ptr->is_err) {
  } else {
    exports_flight_memory_memory_operations_memory_error_free(&ptr->val.err);
  }
}

void exports_flight_memory_memory_operations_list_memory_allocation_free(exports_flight_memory_memory_operations_list_memory_allocation_t *ptr) {
  size_t list_len = ptr->len;
  if (list_len > 0) {
    exports_flight_memory_memory_operations_memory_allocation_t *list_ptr = ptr->ptr;
    for (size_t i = 0; i < list_len; i++) {
      exports_flight_memory_memory_operations_memory_allocation_free(&list_ptr[i]);
    }
    free(list_ptr);
  }
}

void exports_flight_memory_memory_operations_result_list_memory_allocation_memory_error_free(exports_flight_memory_memory_operations_result_list_memory_allocation_memory_error_t *ptr) {
  if (!ptr->is_err) {
    exports_flight_memory_memory_operations_list_memory_allocation_free(&ptr->val.ok);
  } else {
    exports_flight_memory_memory_operations_memory_error_free(&ptr->val.err);
  }
}

void exports_flight_memory_memory_analytics_memory_size_free(exports_flight_memory_memory_analytics_memory_size_t *ptr) {
  exports_flight_memory_memory_types_memory_size_free(ptr);
}

void exports_flight_memory_memory_analytics_memory_usage_snapshot_free(exports_flight_memory_memory_analytics_memory_usage_snapshot_t *ptr) {
  exports_flight_memory_memory_types_memory_usage_snapshot_free(ptr);
}

void exports_flight_memory_memory_analytics_memory_error_free(exports_flight_memory_memory_analytics_memory_error_t *ptr) {
  exports_flight_memory_memory_types_memory_error_free(ptr);
}

void exports_flight_memory_memory_analytics_tuple2_memory_purpose_memory_size_free(exports_flight_memory_memory_analytics_tuple2_memory_purpose_memory_size_t *ptr) {
  exports_flight_memory_memory_analytics_memory_size_free(&ptr->f1);
}

void exports_flight_memory_memory_analytics_list_tuple2_memory_purpose_memory_size_free(exports_flight_memory_memory_analytics_list_tuple2_memory_purpose_memory_size_t *ptr) {
  size_t list_len = ptr->len;
  if (list_len > 0) {
    exports_flight_memory_memory_analytics_tuple2_memory_purpose_memory_size_t *list_ptr = ptr->ptr;
    for (size_t i = 0; i < list_len; i++) {
      exports_flight_memory_memory_analytics_tuple2_memory_purpose_memory_size_free(&list_ptr[i]);
    }
    free(list_ptr);
  }
}

void exports_flight_memory_memory_analytics_memory_stats_free(exports_flight_memory_memory_analytics_memory_stats_t *ptr) {
  exports_flight_memory_memory_analytics_memory_size_free(&ptr->peak_memory);
  exports_flight_memory_memory_analytics_memory_size_free(&ptr->current_memory);
  exports_flight_memory_memory_analytics_memory_size_free(&ptr->average_allocation_size);
  exports_flight_memory_memory_analytics_list_tuple2_memory_purpose_memory_size_free(&ptr->usage_by_purpose);
}

void exports_flight_memory_memory_analytics_list_memory_usage_snapshot_free(exports_flight_memory_memory_analytics_list_memory_usage_snapshot_t *ptr) {
  size_t list_len = ptr->len;
  if (list_len > 0) {
    exports_flight_memory_memory_analytics_memory_usage_snapshot_t *list_ptr = ptr->ptr;
    for (size_t i = 0; i < list_len; i++) {
      exports_flight_memory_memory_analytics_memory_usage_snapshot_free(&list_ptr[i]);
    }
    free(list_ptr);
  }
}

void exports_flight_memory_memory_analytics_option_memory_size_free(exports_flight_memory_memory_analytics_option_memory_size_t *ptr) {
  if (ptr->is_some) {
    exports_flight_memory_memory_analytics_memory_size_free(&ptr->val);
  }
}

void exports_flight_memory_memory_analytics_memory_trend_free(exports_flight_memory_memory_analytics_memory_trend_t *ptr) {
  exports_flight_memory_memory_analytics_list_memory_usage_snapshot_free(&ptr->snapshots);
  exports_flight_memory_memory_analytics_option_memory_size_free(&ptr->predicted_peak);
}

void exports_flight_memory_memory_analytics_result_memory_stats_memory_error_free(exports_flight_memory_memory_analytics_result_memory_stats_memory_error_t *ptr) {
  if (!ptr->is_err) {
    exports_flight_memory_memory_analytics_memory_stats_free(&ptr->val.ok);
  } else {
    exports_flight_memory_memory_analytics_memory_error_free(&ptr->val.err);
  }
}

void exports_flight_memory_memory_analytics_result_memory_trend_memory_error_free(exports_flight_memory_memory_analytics_result_memory_trend_memory_error_t *ptr) {
  if (!ptr->is_err) {
    exports_flight_memory_memory_analytics_memory_trend_free(&ptr->val.ok);
  } else {
    exports_flight_memory_memory_analytics_memory_error_free(&ptr->val.err);
  }
}

void exports_flight_memory_memory_analytics_result_string_memory_error_free(exports_flight_memory_memory_analytics_result_string_memory_error_t *ptr) {
  if (!ptr->is_err) {
    flight_memory_string_free(&ptr->val.ok);
  } else {
    exports_flight_memory_memory_analytics_memory_error_free(&ptr->val.err);
  }
}

void flight_memory_string_set(flight_memory_string_t *ret, const char*s) {
  ret->ptr = (uint8_t*) s;
  ret->len = strlen(s);
}

void flight_memory_string_dup(flight_memory_string_t *ret, const char*s) {
  ret->len = strlen(s);
  ret->ptr = (uint8_t*) cabi_realloc(NULL, 0, 1, ret->len * 1);
  memcpy(ret->ptr, s, ret->len * 1);
}

void flight_memory_string_free(flight_memory_string_t *ret) {
  if (ret->len > 0) {
    free(ret->ptr);
  }
  ret->ptr = NULL;
  ret->len = 0;
}

// Component Adapters

__attribute__((__export_name__("flight:memory/memory-operations@1.0.0#create-allocation")))
uint8_t * __wasm_export_exports_flight_memory_memory_operations_create_allocation(uint8_t * arg, size_t arg0, int64_t arg1, uint8_t * arg2, size_t arg3, int32_t arg4) {
  flight_memory_string_t arg5 = (flight_memory_string_t) { (uint8_t*)(arg), (arg0) };
  exports_flight_memory_memory_operations_memory_size_t arg6 = (exports_flight_memory_memory_types_memory_size_t) {
    (uint64_t) (uint64_t) (arg1),
    (flight_memory_string_t) (flight_memory_string_t) { (uint8_t*)(arg2), (arg3) },
  };
  exports_flight_memory_memory_operations_result_memory_allocation_memory_error_t ret;
  exports_flight_memory_memory_operations_memory_allocation_t ok;
  exports_flight_memory_memory_operations_memory_error_t err;
  ret.is_err = !exports_flight_memory_memory_operations_create_allocation(&arg5, &arg6, arg4, &ok, &err);
  if (ret.is_err) {
    ret.val.err = err;
  }
  if (!ret.is_err) {
    ret.val.ok = ok;
  }
  uint8_t *ptr = (uint8_t *) &RET_AREA;
  if ((ret).is_err) {
    const exports_flight_memory_memory_operations_memory_error_t *payload9 = &(ret).val.err;*((int8_t*)(ptr + 0)) = 1;
    *((int8_t*)(ptr + 8)) = (int32_t) (*payload9).code;
    *((size_t*)(ptr + (8+2*sizeof(void*)))) = ((*payload9).message).len;
    *((uint8_t **)(ptr + (8+1*sizeof(void*)))) = (uint8_t *) ((*payload9).message).ptr;
    if (((*payload9).details).is_some) {
      const flight_memory_string_t *payload11 = &((*payload9).details).val;
      *((int8_t*)(ptr + (8+3*sizeof(void*)))) = 1;
      *((size_t*)(ptr + (8+5*sizeof(void*)))) = (*payload11).len;
      *((uint8_t **)(ptr + (8+4*sizeof(void*)))) = (uint8_t *) (*payload11).ptr;
    } else {
      *((int8_t*)(ptr + (8+3*sizeof(void*)))) = 0;
    }
    *((int64_t*)(ptr + (8+6*sizeof(void*)))) = (int64_t) ((*payload9).timestamp);
  } else {
    const exports_flight_memory_memory_operations_memory_allocation_t *payload = &(ret).val.ok;*((int8_t*)(ptr + 0)) = 0;
    *((size_t*)(ptr + (8+1*sizeof(void*)))) = ((*payload).id).len;
    *((uint8_t **)(ptr + 8)) = (uint8_t *) ((*payload).id).ptr;
    *((size_t*)(ptr + (8+3*sizeof(void*)))) = ((*payload).session_id).len;
    *((uint8_t **)(ptr + (8+2*sizeof(void*)))) = (uint8_t *) ((*payload).session_id).ptr;
    *((int64_t*)(ptr + (8+4*sizeof(void*)))) = (int64_t) (((*payload).size).bytes);
    *((size_t*)(ptr + (16+5*sizeof(void*)))) = (((*payload).size).human_readable).len;
    *((uint8_t **)(ptr + (16+4*sizeof(void*)))) = (uint8_t *) (((*payload).size).human_readable).ptr;
    *((int8_t*)(ptr + (16+6*sizeof(void*)))) = (int32_t) (*payload).purpose;
    *((int64_t*)(ptr + (24+6*sizeof(void*)))) = (int64_t) ((*payload).allocated_at);
    if (((*payload).freed_at).is_some) {
      const uint64_t *payload8 = &((*payload).freed_at).val;
      *((int8_t*)(ptr + (32+6*sizeof(void*)))) = 1;
      *((int64_t*)(ptr + (40+6*sizeof(void*)))) = (int64_t) (*payload8);
    } else {
      *((int8_t*)(ptr + (32+6*sizeof(void*)))) = 0;
    }
  }
  return ptr;
}

__attribute__((__export_name__("flight:memory/memory-operations@1.0.0#free-allocation")))
uint8_t * __wasm_export_exports_flight_memory_memory_operations_free_allocation(uint8_t * arg, size_t arg0) {
  flight_memory_string_t arg1 = (flight_memory_string_t) { (uint8_t*)(arg), (arg0) };
  exports_flight_memory_memory_operations_result_bool_memory_error_t ret;
  bool ok;
  exports_flight_memory_memory_operations_memory_error_t err;
  ret.is_err = !exports_flight_memory_memory_operations_free_allocation(&arg1, &ok, &err);
  if (ret.is_err) {
    ret.val.err = err;
  }
  if (!ret.is_err) {
    ret.val.ok = ok;
  }
  uint8_t *ptr = (uint8_t *) &RET_AREA;
  if ((ret).is_err) {
    const exports_flight_memory_memory_operations_memory_error_t *payload2 = &(ret).val.err;*((int8_t*)(ptr + 0)) = 1;
    *((int8_t*)(ptr + 8)) = (int32_t) (*payload2).code;
    *((size_t*)(ptr + (8+2*sizeof(void*)))) = ((*payload2).message).len;
    *((uint8_t **)(ptr + (8+1*sizeof(void*)))) = (uint8_t *) ((*payload2).message).ptr;
    if (((*payload2).details).is_some) {
      const flight_memory_string_t *payload4 = &((*payload2).details).val;
      *((int8_t*)(ptr + (8+3*sizeof(void*)))) = 1;
      *((size_t*)(ptr + (8+5*sizeof(void*)))) = (*payload4).len;
      *((uint8_t **)(ptr + (8+4*sizeof(void*)))) = (uint8_t *) (*payload4).ptr;
    } else {
      *((int8_t*)(ptr + (8+3*sizeof(void*)))) = 0;
    }
    *((int64_t*)(ptr + (8+6*sizeof(void*)))) = (int64_t) ((*payload2).timestamp);
  } else {
    const bool *payload = &(ret).val.ok;*((int8_t*)(ptr + 0)) = 0;
    *((int8_t*)(ptr + 8)) = *payload;
  }
  return ptr;
}

__attribute__((__export_name__("flight:memory/memory-operations@1.0.0#get-memory-snapshot")))
uint8_t * __wasm_export_exports_flight_memory_memory_operations_get_memory_snapshot(uint8_t * arg, size_t arg0) {
  flight_memory_string_t arg1 = (flight_memory_string_t) { (uint8_t*)(arg), (arg0) };
  exports_flight_memory_memory_operations_result_memory_usage_snapshot_memory_error_t ret;
  exports_flight_memory_memory_operations_memory_usage_snapshot_t ok;
  exports_flight_memory_memory_operations_memory_error_t err;
  ret.is_err = !exports_flight_memory_memory_operations_get_memory_snapshot(&arg1, &ok, &err);
  if (ret.is_err) {
    ret.val.err = err;
  }
  if (!ret.is_err) {
    ret.val.ok = ok;
  }
  uint8_t *ptr = (uint8_t *) &RET_AREA;
  if ((ret).is_err) {
    const exports_flight_memory_memory_operations_memory_error_t *payload2 = &(ret).val.err;*((int8_t*)(ptr + 0)) = 1;
    *((int8_t*)(ptr + 8)) = (int32_t) (*payload2).code;
    *((size_t*)(ptr + (8+2*sizeof(void*)))) = ((*payload2).message).len;
    *((uint8_t **)(ptr + (8+1*sizeof(void*)))) = (uint8_t *) ((*payload2).message).ptr;
    if (((*payload2).details).is_some) {
      const flight_memory_string_t *payload4 = &((*payload2).details).val;
      *((int8_t*)(ptr + (8+3*sizeof(void*)))) = 1;
      *((size_t*)(ptr + (8+5*sizeof(void*)))) = (*payload4).len;
      *((uint8_t **)(ptr + (8+4*sizeof(void*)))) = (uint8_t *) (*payload4).ptr;
    } else {
      *((int8_t*)(ptr + (8+3*sizeof(void*)))) = 0;
    }
    *((int64_t*)(ptr + (8+6*sizeof(void*)))) = (int64_t) ((*payload2).timestamp);
  } else {
    const exports_flight_memory_memory_operations_memory_usage_snapshot_t *payload = &(ret).val.ok;*((int8_t*)(ptr + 0)) = 0;
    *((int64_t*)(ptr + 8)) = (int64_t) ((*payload).timestamp);
    *((size_t*)(ptr + (16+1*sizeof(void*)))) = ((*payload).session_id).len;
    *((uint8_t **)(ptr + 16)) = (uint8_t *) ((*payload).session_id).ptr;
    *((size_t*)(ptr + (16+3*sizeof(void*)))) = ((*payload).platform).len;
    *((uint8_t **)(ptr + (16+2*sizeof(void*)))) = (uint8_t *) ((*payload).platform).ptr;
    *((int64_t*)(ptr + (16+4*sizeof(void*)))) = (int64_t) (((*payload).total).bytes);
    *((size_t*)(ptr + (24+5*sizeof(void*)))) = (((*payload).total).human_readable).len;
    *((uint8_t **)(ptr + (24+4*sizeof(void*)))) = (uint8_t *) (((*payload).total).human_readable).ptr;
    *((int64_t*)(ptr + (24+6*sizeof(void*)))) = (int64_t) (((*payload).used).bytes);
    *((size_t*)(ptr + (32+7*sizeof(void*)))) = (((*payload).used).human_readable).len;
    *((uint8_t **)(ptr + (32+6*sizeof(void*)))) = (uint8_t *) (((*payload).used).human_readable).ptr;
    *((int64_t*)(ptr + (32+8*sizeof(void*)))) = (int64_t) (((*payload).available).bytes);
    *((size_t*)(ptr + (40+9*sizeof(void*)))) = (((*payload).available).human_readable).len;
    *((uint8_t **)(ptr + (40+8*sizeof(void*)))) = (uint8_t *) (((*payload).available).human_readable).ptr;
    *((float*)(ptr + (40+10*sizeof(void*)))) = (*payload).fragmentation_ratio;
  }
  return ptr;
}

__attribute__((__export_name__("flight:memory/memory-operations@1.0.0#get-platform-profile")))
uint8_t * __wasm_export_exports_flight_memory_memory_operations_get_platform_profile(uint8_t * arg, size_t arg0) {
  flight_memory_string_t arg1 = (flight_memory_string_t) { (uint8_t*)(arg), (arg0) };
  exports_flight_memory_memory_operations_result_platform_profile_memory_error_t ret;
  exports_flight_memory_memory_operations_platform_profile_t ok;
  exports_flight_memory_memory_operations_memory_error_t err;
  ret.is_err = !exports_flight_memory_memory_operations_get_platform_profile(&arg1, &ok, &err);
  if (ret.is_err) {
    ret.val.err = err;
  }
  if (!ret.is_err) {
    ret.val.ok = ok;
  }
  uint8_t *ptr = (uint8_t *) &RET_AREA;
  if ((ret).is_err) {
    const exports_flight_memory_memory_operations_memory_error_t *payload9 = &(ret).val.err;*((int8_t*)(ptr + 0)) = 1;
    *((int8_t*)(ptr + 8)) = (int32_t) (*payload9).code;
    *((size_t*)(ptr + (8+2*sizeof(void*)))) = ((*payload9).message).len;
    *((uint8_t **)(ptr + (8+1*sizeof(void*)))) = (uint8_t *) ((*payload9).message).ptr;
    if (((*payload9).details).is_some) {
      const flight_memory_string_t *payload11 = &((*payload9).details).val;
      *((int8_t*)(ptr + (8+3*sizeof(void*)))) = 1;
      *((size_t*)(ptr + (8+5*sizeof(void*)))) = (*payload11).len;
      *((uint8_t **)(ptr + (8+4*sizeof(void*)))) = (uint8_t *) (*payload11).ptr;
    } else {
      *((int8_t*)(ptr + (8+3*sizeof(void*)))) = 0;
    }
    *((int64_t*)(ptr + (8+6*sizeof(void*)))) = (int64_t) ((*payload9).timestamp);
  } else {
    const exports_flight_memory_memory_operations_platform_profile_t *payload = &(ret).val.ok;*((int8_t*)(ptr + 0)) = 0;
    switch ((int32_t) (*payload).tag) {
      case 0: {
        const exports_flight_memory_memory_types_memory_size_t *payload2 = &(*payload).val.dreamcast;
        *((int8_t*)(ptr + 8)) = 0;
        *((int64_t*)(ptr + 16)) = (int64_t) ((*payload2).bytes);
        *((size_t*)(ptr + (24+1*sizeof(void*)))) = ((*payload2).human_readable).len;
        *((uint8_t **)(ptr + 24)) = (uint8_t *) ((*payload2).human_readable).ptr;
        break;
      }
      case 1: {
        const exports_flight_memory_memory_types_memory_size_t *payload3 = &(*payload).val.psp;
        *((int8_t*)(ptr + 8)) = 1;
        *((int64_t*)(ptr + 16)) = (int64_t) ((*payload3).bytes);
        *((size_t*)(ptr + (24+1*sizeof(void*)))) = ((*payload3).human_readable).len;
        *((uint8_t **)(ptr + 24)) = (uint8_t *) ((*payload3).human_readable).ptr;
        break;
      }
      case 2: {
        const exports_flight_memory_memory_types_memory_size_t *payload4 = &(*payload).val.vita;
        *((int8_t*)(ptr + 8)) = 2;
        *((int64_t*)(ptr + 16)) = (int64_t) ((*payload4).bytes);
        *((size_t*)(ptr + (24+1*sizeof(void*)))) = ((*payload4).human_readable).len;
        *((uint8_t **)(ptr + 24)) = (uint8_t *) ((*payload4).human_readable).ptr;
        break;
      }
      case 3: {
        const exports_flight_memory_memory_types_memory_size_t *payload5 = &(*payload).val.v6r_small;
        *((int8_t*)(ptr + 8)) = 3;
        *((int64_t*)(ptr + 16)) = (int64_t) ((*payload5).bytes);
        *((size_t*)(ptr + (24+1*sizeof(void*)))) = ((*payload5).human_readable).len;
        *((uint8_t **)(ptr + 24)) = (uint8_t *) ((*payload5).human_readable).ptr;
        break;
      }
      case 4: {
        const exports_flight_memory_memory_types_memory_size_t *payload6 = &(*payload).val.v6r_medium;
        *((int8_t*)(ptr + 8)) = 4;
        *((int64_t*)(ptr + 16)) = (int64_t) ((*payload6).bytes);
        *((size_t*)(ptr + (24+1*sizeof(void*)))) = ((*payload6).human_readable).len;
        *((uint8_t **)(ptr + 24)) = (uint8_t *) ((*payload6).human_readable).ptr;
        break;
      }
      case 5: {
        const exports_flight_memory_memory_types_memory_size_t *payload7 = &(*payload).val.v6r_large;
        *((int8_t*)(ptr + 8)) = 5;
        *((int64_t*)(ptr + 16)) = (int64_t) ((*payload7).bytes);
        *((size_t*)(ptr + (24+1*sizeof(void*)))) = ((*payload7).human_readable).len;
        *((uint8_t **)(ptr + 24)) = (uint8_t *) ((*payload7).human_readable).ptr;
        break;
      }
      case 6: {
        const exports_flight_memory_memory_types_memory_size_t *payload8 = &(*payload).val.custom;
        *((int8_t*)(ptr + 8)) = 6;
        *((int64_t*)(ptr + 16)) = (int64_t) ((*payload8).bytes);
        *((size_t*)(ptr + (24+1*sizeof(void*)))) = ((*payload8).human_readable).len;
        *((uint8_t **)(ptr + 24)) = (uint8_t *) ((*payload8).human_readable).ptr;
        break;
      }
    }
  }
  return ptr;
}

__attribute__((__export_name__("flight:memory/memory-operations@1.0.0#set-memory-limits")))
uint8_t * __wasm_export_exports_flight_memory_memory_operations_set_memory_limits(uint8_t * arg) {
  flight_memory_string_t arg0 = (flight_memory_string_t) { (uint8_t*)(*((uint8_t **) (arg + 0))), (*((size_t*) (arg + sizeof(void*)))) };
  exports_flight_memory_memory_operations_memory_limits_t arg1 = (exports_flight_memory_memory_types_memory_limits_t) {
    (exports_flight_memory_memory_types_memory_size_t) (exports_flight_memory_memory_types_memory_size_t) {
      (uint64_t) (uint64_t) (*((int64_t*) (arg + (2*sizeof(void*))))),
      (flight_memory_string_t) (flight_memory_string_t) { (uint8_t*)(*((uint8_t **) (arg + (8+2*sizeof(void*))))), (*((size_t*) (arg + (8+3*sizeof(void*))))) },
    },
    (exports_flight_memory_memory_types_memory_size_t) (exports_flight_memory_memory_types_memory_size_t) {
      (uint64_t) (uint64_t) (*((int64_t*) (arg + (8+4*sizeof(void*))))),
      (flight_memory_string_t) (flight_memory_string_t) { (uint8_t*)(*((uint8_t **) (arg + (16+4*sizeof(void*))))), (*((size_t*) (arg + (16+5*sizeof(void*))))) },
    },
    (exports_flight_memory_memory_types_memory_size_t) (exports_flight_memory_memory_types_memory_size_t) {
      (uint64_t) (uint64_t) (*((int64_t*) (arg + (16+6*sizeof(void*))))),
      (flight_memory_string_t) (flight_memory_string_t) { (uint8_t*)(*((uint8_t **) (arg + (24+6*sizeof(void*))))), (*((size_t*) (arg + (24+7*sizeof(void*))))) },
    },
    (exports_flight_memory_memory_types_memory_size_t) (exports_flight_memory_memory_types_memory_size_t) {
      (uint64_t) (uint64_t) (*((int64_t*) (arg + (24+8*sizeof(void*))))),
      (flight_memory_string_t) (flight_memory_string_t) { (uint8_t*)(*((uint8_t **) (arg + (32+8*sizeof(void*))))), (*((size_t*) (arg + (32+9*sizeof(void*))))) },
    },
    (exports_flight_memory_memory_types_memory_size_t) (exports_flight_memory_memory_types_memory_size_t) {
      (uint64_t) (uint64_t) (*((int64_t*) (arg + (32+10*sizeof(void*))))),
      (flight_memory_string_t) (flight_memory_string_t) { (uint8_t*)(*((uint8_t **) (arg + (40+10*sizeof(void*))))), (*((size_t*) (arg + (40+11*sizeof(void*))))) },
    },
  };
  exports_flight_memory_memory_operations_result_bool_memory_error_t ret;
  bool ok;
  exports_flight_memory_memory_operations_memory_error_t err;
  ret.is_err = !exports_flight_memory_memory_operations_set_memory_limits(&arg0, &arg1, &ok, &err);
  if (ret.is_err) {
    ret.val.err = err;
  }
  if (!ret.is_err) {
    ret.val.ok = ok;
  }
  free(arg);
  uint8_t *ptr = (uint8_t *) &RET_AREA;
  if ((ret).is_err) {
    const exports_flight_memory_memory_operations_memory_error_t *payload2 = &(ret).val.err;*((int8_t*)(ptr + 0)) = 1;
    *((int8_t*)(ptr + 8)) = (int32_t) (*payload2).code;
    *((size_t*)(ptr + (8+2*sizeof(void*)))) = ((*payload2).message).len;
    *((uint8_t **)(ptr + (8+1*sizeof(void*)))) = (uint8_t *) ((*payload2).message).ptr;
    if (((*payload2).details).is_some) {
      const flight_memory_string_t *payload4 = &((*payload2).details).val;
      *((int8_t*)(ptr + (8+3*sizeof(void*)))) = 1;
      *((size_t*)(ptr + (8+5*sizeof(void*)))) = (*payload4).len;
      *((uint8_t **)(ptr + (8+4*sizeof(void*)))) = (uint8_t *) (*payload4).ptr;
    } else {
      *((int8_t*)(ptr + (8+3*sizeof(void*)))) = 0;
    }
    *((int64_t*)(ptr + (8+6*sizeof(void*)))) = (int64_t) ((*payload2).timestamp);
  } else {
    const bool *payload = &(ret).val.ok;*((int8_t*)(ptr + 0)) = 0;
    *((int8_t*)(ptr + 8)) = *payload;
  }
  return ptr;
}

__attribute__((__export_name__("flight:memory/memory-operations@1.0.0#get-memory-limits")))
uint8_t * __wasm_export_exports_flight_memory_memory_operations_get_memory_limits(uint8_t * arg, size_t arg0) {
  flight_memory_string_t arg1 = (flight_memory_string_t) { (uint8_t*)(arg), (arg0) };
  exports_flight_memory_memory_operations_result_memory_limits_memory_error_t ret;
  exports_flight_memory_memory_operations_memory_limits_t ok;
  exports_flight_memory_memory_operations_memory_error_t err;
  ret.is_err = !exports_flight_memory_memory_operations_get_memory_limits(&arg1, &ok, &err);
  if (ret.is_err) {
    ret.val.err = err;
  }
  if (!ret.is_err) {
    ret.val.ok = ok;
  }
  uint8_t *ptr = (uint8_t *) &RET_AREA;
  if ((ret).is_err) {
    const exports_flight_memory_memory_operations_memory_error_t *payload2 = &(ret).val.err;*((int8_t*)(ptr + 0)) = 1;
    *((int8_t*)(ptr + 8)) = (int32_t) (*payload2).code;
    *((size_t*)(ptr + (8+2*sizeof(void*)))) = ((*payload2).message).len;
    *((uint8_t **)(ptr + (8+1*sizeof(void*)))) = (uint8_t *) ((*payload2).message).ptr;
    if (((*payload2).details).is_some) {
      const flight_memory_string_t *payload4 = &((*payload2).details).val;
      *((int8_t*)(ptr + (8+3*sizeof(void*)))) = 1;
      *((size_t*)(ptr + (8+5*sizeof(void*)))) = (*payload4).len;
      *((uint8_t **)(ptr + (8+4*sizeof(void*)))) = (uint8_t *) (*payload4).ptr;
    } else {
      *((int8_t*)(ptr + (8+3*sizeof(void*)))) = 0;
    }
    *((int64_t*)(ptr + (8+6*sizeof(void*)))) = (int64_t) ((*payload2).timestamp);
  } else {
    const exports_flight_memory_memory_operations_memory_limits_t *payload = &(ret).val.ok;*((int8_t*)(ptr + 0)) = 0;
    *((int64_t*)(ptr + 8)) = (int64_t) (((*payload).heap_max).bytes);
    *((size_t*)(ptr + (16+1*sizeof(void*)))) = (((*payload).heap_max).human_readable).len;
    *((uint8_t **)(ptr + 16)) = (uint8_t *) (((*payload).heap_max).human_readable).ptr;
    *((int64_t*)(ptr + (16+2*sizeof(void*)))) = (int64_t) (((*payload).stack_max).bytes);
    *((size_t*)(ptr + (24+3*sizeof(void*)))) = (((*payload).stack_max).human_readable).len;
    *((uint8_t **)(ptr + (24+2*sizeof(void*)))) = (uint8_t *) (((*payload).stack_max).human_readable).ptr;
    *((int64_t*)(ptr + (24+4*sizeof(void*)))) = (int64_t) (((*payload).cache_max).bytes);
    *((size_t*)(ptr + (32+5*sizeof(void*)))) = (((*payload).cache_max).human_readable).len;
    *((uint8_t **)(ptr + (32+4*sizeof(void*)))) = (uint8_t *) (((*payload).cache_max).human_readable).ptr;
    *((int64_t*)(ptr + (32+6*sizeof(void*)))) = (int64_t) (((*payload).soft_limit).bytes);
    *((size_t*)(ptr + (40+7*sizeof(void*)))) = (((*payload).soft_limit).human_readable).len;
    *((uint8_t **)(ptr + (40+6*sizeof(void*)))) = (uint8_t *) (((*payload).soft_limit).human_readable).ptr;
    *((int64_t*)(ptr + (40+8*sizeof(void*)))) = (int64_t) (((*payload).hard_limit).bytes);
    *((size_t*)(ptr + (48+9*sizeof(void*)))) = (((*payload).hard_limit).human_readable).len;
    *((uint8_t **)(ptr + (48+8*sizeof(void*)))) = (uint8_t *) (((*payload).hard_limit).human_readable).ptr;
  }
  return ptr;
}

__attribute__((__export_name__("flight:memory/memory-operations@1.0.0#get-memory-pressure")))
uint8_t * __wasm_export_exports_flight_memory_memory_operations_get_memory_pressure(uint8_t * arg, size_t arg0) {
  flight_memory_string_t arg1 = (flight_memory_string_t) { (uint8_t*)(arg), (arg0) };
  exports_flight_memory_memory_operations_result_memory_pressure_memory_error_t ret;
  exports_flight_memory_memory_operations_memory_pressure_t ok;
  exports_flight_memory_memory_operations_memory_error_t err;
  ret.is_err = !exports_flight_memory_memory_operations_get_memory_pressure(&arg1, &ok, &err);
  if (ret.is_err) {
    ret.val.err = err;
  }
  if (!ret.is_err) {
    ret.val.ok = ok;
  }
  uint8_t *ptr = (uint8_t *) &RET_AREA;
  if ((ret).is_err) {
    const exports_flight_memory_memory_operations_memory_error_t *payload2 = &(ret).val.err;*((int8_t*)(ptr + 0)) = 1;
    *((int8_t*)(ptr + 8)) = (int32_t) (*payload2).code;
    *((size_t*)(ptr + (8+2*sizeof(void*)))) = ((*payload2).message).len;
    *((uint8_t **)(ptr + (8+1*sizeof(void*)))) = (uint8_t *) ((*payload2).message).ptr;
    if (((*payload2).details).is_some) {
      const flight_memory_string_t *payload4 = &((*payload2).details).val;
      *((int8_t*)(ptr + (8+3*sizeof(void*)))) = 1;
      *((size_t*)(ptr + (8+5*sizeof(void*)))) = (*payload4).len;
      *((uint8_t **)(ptr + (8+4*sizeof(void*)))) = (uint8_t *) (*payload4).ptr;
    } else {
      *((int8_t*)(ptr + (8+3*sizeof(void*)))) = 0;
    }
    *((int64_t*)(ptr + (8+6*sizeof(void*)))) = (int64_t) ((*payload2).timestamp);
  } else {
    const exports_flight_memory_memory_operations_memory_pressure_t *payload = &(ret).val.ok;*((int8_t*)(ptr + 0)) = 0;
    *((int8_t*)(ptr + 8)) = (int32_t) *payload;
  }
  return ptr;
}

__attribute__((__export_name__("flight:memory/memory-operations@1.0.0#validate-allocation-request")))
uint8_t * __wasm_export_exports_flight_memory_memory_operations_validate_allocation_request(uint8_t * arg, size_t arg0, int64_t arg1, uint8_t * arg2, size_t arg3, int32_t arg4) {
  flight_memory_string_t arg5 = (flight_memory_string_t) { (uint8_t*)(arg), (arg0) };
  exports_flight_memory_memory_operations_memory_size_t arg6 = (exports_flight_memory_memory_types_memory_size_t) {
    (uint64_t) (uint64_t) (arg1),
    (flight_memory_string_t) (flight_memory_string_t) { (uint8_t*)(arg2), (arg3) },
  };
  exports_flight_memory_memory_operations_result_bool_memory_error_t ret;
  bool ok;
  exports_flight_memory_memory_operations_memory_error_t err;
  ret.is_err = !exports_flight_memory_memory_operations_validate_allocation_request(&arg5, &arg6, arg4, &ok, &err);
  if (ret.is_err) {
    ret.val.err = err;
  }
  if (!ret.is_err) {
    ret.val.ok = ok;
  }
  uint8_t *ptr = (uint8_t *) &RET_AREA;
  if ((ret).is_err) {
    const exports_flight_memory_memory_operations_memory_error_t *payload7 = &(ret).val.err;*((int8_t*)(ptr + 0)) = 1;
    *((int8_t*)(ptr + 8)) = (int32_t) (*payload7).code;
    *((size_t*)(ptr + (8+2*sizeof(void*)))) = ((*payload7).message).len;
    *((uint8_t **)(ptr + (8+1*sizeof(void*)))) = (uint8_t *) ((*payload7).message).ptr;
    if (((*payload7).details).is_some) {
      const flight_memory_string_t *payload9 = &((*payload7).details).val;
      *((int8_t*)(ptr + (8+3*sizeof(void*)))) = 1;
      *((size_t*)(ptr + (8+5*sizeof(void*)))) = (*payload9).len;
      *((uint8_t **)(ptr + (8+4*sizeof(void*)))) = (uint8_t *) (*payload9).ptr;
    } else {
      *((int8_t*)(ptr + (8+3*sizeof(void*)))) = 0;
    }
    *((int64_t*)(ptr + (8+6*sizeof(void*)))) = (int64_t) ((*payload7).timestamp);
  } else {
    const bool *payload = &(ret).val.ok;*((int8_t*)(ptr + 0)) = 0;
    *((int8_t*)(ptr + 8)) = *payload;
  }
  return ptr;
}

__attribute__((__export_name__("flight:memory/memory-operations@1.0.0#list-allocations")))
uint8_t * __wasm_export_exports_flight_memory_memory_operations_list_allocations(uint8_t * arg, size_t arg0) {
  flight_memory_string_t arg1 = (flight_memory_string_t) { (uint8_t*)(arg), (arg0) };
  exports_flight_memory_memory_operations_result_list_memory_allocation_memory_error_t ret;
  exports_flight_memory_memory_operations_list_memory_allocation_t ok;
  exports_flight_memory_memory_operations_memory_error_t err;
  ret.is_err = !exports_flight_memory_memory_operations_list_allocations(&arg1, &ok, &err);
  if (ret.is_err) {
    ret.val.err = err;
  }
  if (!ret.is_err) {
    ret.val.ok = ok;
  }
  uint8_t *ptr = (uint8_t *) &RET_AREA;
  if ((ret).is_err) {
    const exports_flight_memory_memory_operations_memory_error_t *payload4 = &(ret).val.err;*((int8_t*)(ptr + 0)) = 1;
    *((int8_t*)(ptr + 8)) = (int32_t) (*payload4).code;
    *((size_t*)(ptr + (8+2*sizeof(void*)))) = ((*payload4).message).len;
    *((uint8_t **)(ptr + (8+1*sizeof(void*)))) = (uint8_t *) ((*payload4).message).ptr;
    if (((*payload4).details).is_some) {
      const flight_memory_string_t *payload6 = &((*payload4).details).val;
      *((int8_t*)(ptr + (8+3*sizeof(void*)))) = 1;
      *((size_t*)(ptr + (8+5*sizeof(void*)))) = (*payload6).len;
      *((uint8_t **)(ptr + (8+4*sizeof(void*)))) = (uint8_t *) (*payload6).ptr;
    } else {
      *((int8_t*)(ptr + (8+3*sizeof(void*)))) = 0;
    }
    *((int64_t*)(ptr + (8+6*sizeof(void*)))) = (int64_t) ((*payload4).timestamp);
  } else {
    const exports_flight_memory_memory_operations_list_memory_allocation_t *payload = &(ret).val.ok;*((int8_t*)(ptr + 0)) = 0;
    *((size_t*)(ptr + (8+1*sizeof(void*)))) = (*payload).len;
    *((uint8_t **)(ptr + 8)) = (uint8_t *) (*payload).ptr;
  }
  return ptr;
}

__attribute__((__export_name__("flight:memory/memory-analytics@1.0.0#calculate-memory-stats")))
uint8_t * __wasm_export_exports_flight_memory_memory_analytics_calculate_memory_stats(uint8_t * arg, size_t arg0) {
  flight_memory_string_t arg1 = (flight_memory_string_t) { (uint8_t*)(arg), (arg0) };
  exports_flight_memory_memory_analytics_result_memory_stats_memory_error_t ret;
  exports_flight_memory_memory_analytics_memory_stats_t ok;
  exports_flight_memory_memory_analytics_memory_error_t err;
  ret.is_err = !exports_flight_memory_memory_analytics_calculate_memory_stats(&arg1, &ok, &err);
  if (ret.is_err) {
    ret.val.err = err;
  }
  if (!ret.is_err) {
    ret.val.ok = ok;
  }
  uint8_t *ptr = (uint8_t *) &RET_AREA;
  if ((ret).is_err) {
    const exports_flight_memory_memory_analytics_memory_error_t *payload2 = &(ret).val.err;*((int8_t*)(ptr + 0)) = 1;
    *((int8_t*)(ptr + 8)) = (int32_t) (*payload2).code;
    *((size_t*)(ptr + (8+2*sizeof(void*)))) = ((*payload2).message).len;
    *((uint8_t **)(ptr + (8+1*sizeof(void*)))) = (uint8_t *) ((*payload2).message).ptr;
    if (((*payload2).details).is_some) {
      const flight_memory_string_t *payload4 = &((*payload2).details).val;
      *((int8_t*)(ptr + (8+3*sizeof(void*)))) = 1;
      *((size_t*)(ptr + (8+5*sizeof(void*)))) = (*payload4).len;
      *((uint8_t **)(ptr + (8+4*sizeof(void*)))) = (uint8_t *) (*payload4).ptr;
    } else {
      *((int8_t*)(ptr + (8+3*sizeof(void*)))) = 0;
    }
    *((int64_t*)(ptr + (8+6*sizeof(void*)))) = (int64_t) ((*payload2).timestamp);
  } else {
    const exports_flight_memory_memory_analytics_memory_stats_t *payload = &(ret).val.ok;*((int8_t*)(ptr + 0)) = 0;
    *((int64_t*)(ptr + 8)) = (int64_t) ((*payload).total_allocations);
    *((int64_t*)(ptr + 16)) = (int64_t) ((*payload).active_allocations);
    *((int64_t*)(ptr + 24)) = (int64_t) (((*payload).peak_memory).bytes);
    *((size_t*)(ptr + (32+1*sizeof(void*)))) = (((*payload).peak_memory).human_readable).len;
    *((uint8_t **)(ptr + 32)) = (uint8_t *) (((*payload).peak_memory).human_readable).ptr;
    *((int64_t*)(ptr + (32+2*sizeof(void*)))) = (int64_t) (((*payload).current_memory).bytes);
    *((size_t*)(ptr + (40+3*sizeof(void*)))) = (((*payload).current_memory).human_readable).len;
    *((uint8_t **)(ptr + (40+2*sizeof(void*)))) = (uint8_t *) (((*payload).current_memory).human_readable).ptr;
    *((int64_t*)(ptr + (40+4*sizeof(void*)))) = (int64_t) (((*payload).average_allocation_size).bytes);
    *((size_t*)(ptr + (48+5*sizeof(void*)))) = (((*payload).average_allocation_size).human_readable).len;
    *((uint8_t **)(ptr + (48+4*sizeof(void*)))) = (uint8_t *) (((*payload).average_allocation_size).human_readable).ptr;
    *((size_t*)(ptr + (48+7*sizeof(void*)))) = ((*payload).usage_by_purpose).len;
    *((uint8_t **)(ptr + (48+6*sizeof(void*)))) = (uint8_t *) ((*payload).usage_by_purpose).ptr;
    *((float*)(ptr + (48+8*sizeof(void*)))) = (*payload).efficiency_ratio;
  }
  return ptr;
}

__attribute__((__export_name__("flight:memory/memory-analytics@1.0.0#get-memory-trends")))
uint8_t * __wasm_export_exports_flight_memory_memory_analytics_get_memory_trends(uint8_t * arg, size_t arg0, int64_t arg1) {
  flight_memory_string_t arg2 = (flight_memory_string_t) { (uint8_t*)(arg), (arg0) };
  exports_flight_memory_memory_analytics_result_memory_trend_memory_error_t ret;
  exports_flight_memory_memory_analytics_memory_trend_t ok;
  exports_flight_memory_memory_analytics_memory_error_t err;
  ret.is_err = !exports_flight_memory_memory_analytics_get_memory_trends(&arg2, (uint64_t) (arg1), &ok, &err);
  if (ret.is_err) {
    ret.val.err = err;
  }
  if (!ret.is_err) {
    ret.val.ok = ok;
  }
  uint8_t *ptr = (uint8_t *) &RET_AREA;
  if ((ret).is_err) {
    const exports_flight_memory_memory_analytics_memory_error_t *payload5 = &(ret).val.err;*((int8_t*)(ptr + 0)) = 1;
    *((int8_t*)(ptr + 8)) = (int32_t) (*payload5).code;
    *((size_t*)(ptr + (8+2*sizeof(void*)))) = ((*payload5).message).len;
    *((uint8_t **)(ptr + (8+1*sizeof(void*)))) = (uint8_t *) ((*payload5).message).ptr;
    if (((*payload5).details).is_some) {
      const flight_memory_string_t *payload7 = &((*payload5).details).val;
      *((int8_t*)(ptr + (8+3*sizeof(void*)))) = 1;
      *((size_t*)(ptr + (8+5*sizeof(void*)))) = (*payload7).len;
      *((uint8_t **)(ptr + (8+4*sizeof(void*)))) = (uint8_t *) (*payload7).ptr;
    } else {
      *((int8_t*)(ptr + (8+3*sizeof(void*)))) = 0;
    }
    *((int64_t*)(ptr + (8+6*sizeof(void*)))) = (int64_t) ((*payload5).timestamp);
  } else {
    const exports_flight_memory_memory_analytics_memory_trend_t *payload = &(ret).val.ok;*((int8_t*)(ptr + 0)) = 0;
    *((size_t*)(ptr + (8+1*sizeof(void*)))) = ((*payload).snapshots).len;
    *((uint8_t **)(ptr + 8)) = (uint8_t *) ((*payload).snapshots).ptr;
    *((int8_t*)(ptr + (8+2*sizeof(void*)))) = (int32_t) (*payload).trend_direction;
    if (((*payload).predicted_peak).is_some) {
      const exports_flight_memory_memory_analytics_memory_size_t *payload4 = &((*payload).predicted_peak).val;
      *((int8_t*)(ptr + (16+2*sizeof(void*)))) = 1;
      *((int64_t*)(ptr + (24+2*sizeof(void*)))) = (int64_t) ((*payload4).bytes);
      *((size_t*)(ptr + (32+3*sizeof(void*)))) = ((*payload4).human_readable).len;
      *((uint8_t **)(ptr + (32+2*sizeof(void*)))) = (uint8_t *) ((*payload4).human_readable).ptr;
    } else {
      *((int8_t*)(ptr + (16+2*sizeof(void*)))) = 0;
    }
  }
  return ptr;
}

__attribute__((__export_name__("flight:memory/memory-analytics@1.0.0#generate-memory-report")))
uint8_t * __wasm_export_exports_flight_memory_memory_analytics_generate_memory_report(uint8_t * arg, size_t arg0) {
  flight_memory_string_t arg1 = (flight_memory_string_t) { (uint8_t*)(arg), (arg0) };
  exports_flight_memory_memory_analytics_result_string_memory_error_t ret;
  flight_memory_string_t ok;
  exports_flight_memory_memory_analytics_memory_error_t err;
  ret.is_err = !exports_flight_memory_memory_analytics_generate_memory_report(&arg1, &ok, &err);
  if (ret.is_err) {
    ret.val.err = err;
  }
  if (!ret.is_err) {
    ret.val.ok = ok;
  }
  uint8_t *ptr = (uint8_t *) &RET_AREA;
  if ((ret).is_err) {
    const exports_flight_memory_memory_analytics_memory_error_t *payload2 = &(ret).val.err;*((int8_t*)(ptr + 0)) = 1;
    *((int8_t*)(ptr + 8)) = (int32_t) (*payload2).code;
    *((size_t*)(ptr + (8+2*sizeof(void*)))) = ((*payload2).message).len;
    *((uint8_t **)(ptr + (8+1*sizeof(void*)))) = (uint8_t *) ((*payload2).message).ptr;
    if (((*payload2).details).is_some) {
      const flight_memory_string_t *payload4 = &((*payload2).details).val;
      *((int8_t*)(ptr + (8+3*sizeof(void*)))) = 1;
      *((size_t*)(ptr + (8+5*sizeof(void*)))) = (*payload4).len;
      *((uint8_t **)(ptr + (8+4*sizeof(void*)))) = (uint8_t *) (*payload4).ptr;
    } else {
      *((int8_t*)(ptr + (8+3*sizeof(void*)))) = 0;
    }
    *((int64_t*)(ptr + (8+6*sizeof(void*)))) = (int64_t) ((*payload2).timestamp);
  } else {
    const flight_memory_string_t *payload = &(ret).val.ok;*((int8_t*)(ptr + 0)) = 0;
    *((size_t*)(ptr + (8+1*sizeof(void*)))) = (*payload).len;
    *((uint8_t **)(ptr + 8)) = (uint8_t *) (*payload).ptr;
  }
  return ptr;
}

// Ensure that the *_component_type.o object is linked in

extern void __component_type_object_force_link_flight_memory(void);
void __component_type_object_force_link_flight_memory_public_use_in_this_compilation_unit(void) {
  __component_type_object_force_link_flight_memory();
}
